import numpy as np
import matplotlib.pyplot as plt
from numpy import *
from numpy.fft import *
from matplotlib.pyplot import *
#from rtlsdr import RtlSdr
from scipy.io import wavfile
from scipy import signal


def packed_bytes_to_iq(file_path):
    sample_rate, iq_data = wavfile.read(file_path, mmap=True)

    iq_data = np.ctypeslib.as_array(iq_data[2000:74800])
    iq_data = iq_data.astype(np.float64).view(np.complex128)

    iq_data /= 127.5
    iq_data -= (1 + 1j)

    return sample_rate, iq_data.reshape(len(iq_data))


def avg_power_spectrum(x, N=256, fs=1):
    M = int(floor(len(x) / N))
    x_ = reshape(x[:M * N], (M, N)) * np.hamming(N)[None, :]
    X = np.fft.fftshift(np.fft.fft(x_, axis=1), axes=1)

    return r_[-N / 2.0:N / 2.0] / N * fs, mean(abs(X ** 2), axis=0)


def spectrogram_plot(t_range, f_range, y, dbf=60, fig=None):
    eps = 10.0 ** (-dbf / 20.0)  # minimum signal

    # find maximum
    y_max = abs(y).max()

    # compute 20*log magnitude, scaled to the max
    y_log = 20.0 * np.log10((abs(y) / y_max) * (1 - eps) + eps)

    # rescale image intensity to 256
    img = 256 * (y_log + dbf) / dbf - 1

    fig = figure(figsize=(16, 6))

    plt.imshow(np.flipud(64.0 * (y_log + dbf) / dbf),
               extent=t_range + f_range, cmap=plt.cm.gray, aspect='auto')
    plt.xlabel('Time, s')
    plt.ylabel('Frequency, Hz')
    plt.tight_layout()


def spectrogram_hann_ovlp(x, m, fs, fc, dbf=60, fig=None):
    # check if x is real
    isreal_bool = isreal(x).all()

    lx = len(x)
    nt = (lx + m - 1) // m
    x = append(x, zeros(-lx + nt * m))
    x = x.reshape((m // 2, nt * 2), order='F')
    x = concatenate((x, x), axis=0)
    x = x.reshape((m * nt * 2, 1), order='F')
    x = x[r_[m // 2:len(x), ones(m // 2) * (len(x) - 1)
             ].astype(int)].reshape((m, nt * 2), order='F')

    xmw = x * hanning(m)[:, None]

    # frequency index
    t_range = [0.0, lx / fs]

    if isreal_bool:
        f_range = [fc, fs / 2.0 + fc]
        xmf = fft(xmw, len(xmw), axis=0)
        fig = spectrogram_plot(t_range, f_range, xmf[0:m // 2, :], dbf, fig)
    else:
        f_range = [-fs / 2.0 + fc, fs / 2.0 + fc]
        xmf = abs(fftshift(fft(xmw, len(xmw), axis=0), axes=0))
        fig = spectrogram_plot(t_range, f_range, xmf, dbf, fig)

    return fig

def locateBurst(x, fs):
        # use to  find the starting and ending FCCH bursts in a given signal part
        #  Inputs:
        #           x  - signal array
        #           fs - sampling frequency
        #
        #  Outputs:
        #           fcch_idx_pos and array which havw starting and ending indexes of bursts
        #
        
        burst_t = 576.9e-6 #seconds
        half_len = fs*burst_t//2 + 3

        normed = (abs(x)/max(abs(x)))**2
        normed[normed < 0.5] = 0
        
        pulses = []
        for i in range(len(normed)-2):
            if normed[i+1]>normed[i] and normed[i+1]>normed[i+2]:
                if(i-half_len < 0 or i+half_len >= len(normed)-2):
                    continue
                else:
                    pulses += [(i+1-half_len, i+1+half_len)]

        return np.array(pulses)   


def findOffset(data, fcch_pos, fcc, nbw):
        # use to calculate the offset
        # Inputs:
        #        data - an array of data
        #        fcch_pos - positions of fcch bursts generated by locateBurst
        #        fcc   - estimated fcch frequency, which you used to demodulate the data
        #        nbw  -   sampling rate of the data
        #
        # Outputs:
        #       offset - The estimated frequency offset with respect to ideal fcch frequency.
        
        L = nbw//10 # for fft res = 10 Hz
        
        ffts = []
        # print(type(fcch_pos))
        fcch_pos = fcch_pos.astype(np.int64)
        for i in range(len(fcch_pos)):
            ffts += [np.fft.fft(append(data[fcch_pos[i][0]:fcch_pos[i][1]], zeros(L-(fcch_pos[i][1]-fcch_pos[i][0]))))]
        mean_power = np.mean(np.fft.fftshift(abs(np.array(ffts)))**2, axis=0)
        idx = np.argmax(mean_power)
        fcch = idx*(nbw/L)
        
        return (fcch) - (1625000.0 / 6.0) / 4.0  



def main(filepath, fc):

    fs, data = packed_bytes_to_iq(filepath)
    print(f"Sample rate used: {fs}")

    # Usage of Pyrtlsdr API - pending work [Just written for note]

    # sdr = RtlSdr()
    # sdr.sample_rate = fs
    # sdr.gain = gain
    # sdr.center_freq = fc
    # sdr.set_freq_correction(ppm)
    # data = sdr.read_samples(25600*3)[2000:] #first 2000 samples are not good
    # sdr.close()

    # compute average power spectrum
    f, sp = avg_power_spectrum(data, N=256, fs=fs / 1000)

    fig = figure(figsize=(8, 4))
    plot(f, 10 * log10(sp))
    title('average power spectrum of GSM')
    xlabel('frequency offset [KHz]')
    plt.show()

    # plot of TDMA frames
    fig = figure(figsize=(16, 4))
    plot(r_[0:12000.0] / fs * 1000, abs(data[:12000]))
    title('Magnitude GSM signal, showing TDMA frames')
    xlabel('t [ms]')
    plt.show()

    spectrogram_hann_ovlp(data, 156, fs, fc, dbf=60)
    plt.show()

    # Simple specgram
    plt.specgram(data, NFFT=256, Fs=fs)
    plt.title("Power spectral density of signal")
    plt.xlabel("Time")
    plt.ylabel("Frequency")
    plt.show()

    # plt.psd(data, NFFT=256, Fs=fs)
    # plt.title("PSD of 'signal' loaded from file")
    # plt.show()

    # sampling rate fs = 240e3 samples/second
    burst_t = 576.9e-6 #seconds
    burst_len = 1 + fs*burst_t//1 # == 139 samples
    fcc = fc + 640000 # approximate frequency of the FCCH burst
    demod_data = np.exp(-1j * fcc * np.linspace(0,len(data),len(data)))*data

    h = signal.firwin(141,7500,nyq=2400000.0/2,window='hanning')
    filtered_data = signal.fftconvolve(demod_data, h)[::10]
    
    pos = locateBurst(filtered_data,fs/10)

    offset = findOffset(filtered_data, pos, fcc,fs)
    print("OFFSET :" , offset)

    ppm = offset / (fcc + (1625000.0 / 6.0) / 4.0)*1e6
    print("PPM :" , ppm)

# def main():
#     print("there is no gsm support in CalibrateSDR yet. If you know how to do it, please feel free to add it :)")
#     print("or you can use Kalibrate-RTL from https://github.com/steve-m/kalibrate-rtl in the meantime")

# if __name__ == '__main__':
#     main()